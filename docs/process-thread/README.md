# 进程与线程

## 基本思想

::: tip 概括（区别）
（1）进程是一个容器。

（2）线程是容器中的工作单位。
:::

## 什么是进程

定义: 进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。
::: tip 进程释义
进程是一段程序的执行过程
:::

### 特征

动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；

并发性：任何进程都可以同其他进行一起并发执行；

独立性：进程是系统进行资源分配和调度的一个独立单位；

结构性：进程由程序，数据和进程控制块三部分组成

同一程序同时运行于若干个数据集合上，它将属于若干个不同的进程，也就是说同一程序可以对应多个进程。

## 什么是线程

定义: 线程（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。

::: tip 线程释义
程序执行流的最小单元
:::

## 一个白话举例

[来源-人民邮电出版社知乎回答](https://www.zhihu.com/question/25532384/answer/81152571)

假设你经营着一家物业管理公司。最初，业务量很小，事事都需要你亲力亲为。给老张家修完暖气管道，立马再去老李家换电灯泡——这叫<b>单线程，所有的工作都得顺序执行</b>。

后来业务拓展了，你雇佣了几个工人，这样，你的物业公司就可以同时为多户人家提供服务了——这叫<b>多线程</b>，你是主线程。

工人们使用的工具，是物业管理公司提供的，这些工具由大家共享，并不专属于某一个人——这叫<b>多线程资源共享</b>。

工人们在工作中都需要管钳，可是管钳只有一把——这叫<b>冲突</b>。解决冲突的办法有很多，比如排队等候、等同事用完后的微信通知等——这叫<b>线程同步</b>。

你给工人布置任务——这叫<b>创建线程</b>。之后你还得要告诉他，可以开始了，不然他会一直停在那儿不动——这叫<b>启动线程（start）</b>。

如果某个工人（线程）的工作非常重要，你（主线程）也许会亲自监工一段时间，如果不指定时间，则表示你会一直监工到该项工作完成——这叫<b>线程参与（join）</b>。

业务不忙的时候，你就在办公室喝喝茶。下班时间一到，你群发微信，所有的工人不管手头的工作是否完成，都立马撂下工具，跟你走人。因此如果有必要，你得避免不要在工人正忙着的时候发下班的通知——这叫<b>线程守护属性设置和管理（daemon）</b>。

再后来，你的公司规模扩大了，同时为很多生活社区服务，你在每个生活社区设置了分公司，分公司由分公司经理管理，运营机制和你的总公司几乎一模一样——这叫<b>多进程</b>，总公司叫主进程，分公司叫子进程。

总公司和分公司，以及各个分公司之间，工具都是独立的，不能借用、混用——这叫<b>进程间不能共享资源</b>。各个分公司之间可以通过专线电话联系——这叫<b>管道</b>。各个分公司之间还可以通过公司公告栏交换信息——这叫<b>进程间共享内存</b>。另外，各个分公司之间还有各种协同手段，以便完成更大规模的作业——这叫<b>进程间同步</b>。分公司可以跟着总公司一起下班，也可以把当天的工作全部做完之后再下班——这叫<b>守护进程设置</b>。

## 又一个白话举例

[来源-阮一峰](http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html)

1.
<img :src="$withBase('/process-thread/1.jpeg')" alt="1">

计算机的核心是 CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。

2.
<img :src="$withBase('/process-thread/2.png')" alt="2">

假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个 CPU 一次只能运行一个任务。

3.
<img :src="$withBase('/process-thread/3.jpeg')" alt="3">

进程就好比工厂的车间，它代表 CPU 所能处理的单个任务。任一时刻，CPU 总是运行一个进程，其他进程处于非运行状态。

4.
<img :src="$withBase('/process-thread/4.jpeg')" alt="4">

一个车间里，可以有很多工人。他们协同完成一个任务。

5.
<img :src="$withBase('/process-thread/5.jpeg')" alt="5">

线程就好比车间里的工人。一个进程可以包括多个线程。

6.
<img :src="$withBase('/process-thread/6.png')" alt="6">

车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。

7.
<img :src="$withBase('/process-thread/7.jpeg')" alt="7">

可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。

8.
<img :src="$withBase('/process-thread/8.jpeg')" alt="8">

一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫"互斥锁"（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。

::: tip 互斥锁
在编程中，引入了对象互斥锁的概念，来保证共享数据操作的完整性。每个对象都对应于一个可称为" 互斥锁" 的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。
:::

9.
<img :src="$withBase('/process-thread/9.jpeg')" alt="9">

还有些房间，可以同时容纳 n 个人，比如厨房。也就是说，如果人数大于 n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。

10.
<img :src="$withBase('/process-thread/10.jpeg')" alt="10">

这时的解决方法，就是在门口挂 n 把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做"信号量"（Semaphore），用来保证多个线程不会互相冲突。

不难看出，mutex 是 semaphore 的一种特殊情况（n=1 时）。也就是说，完全可以用后者替代前者。但是，因为 mutex 较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。

::: tip 信号量
信号量(Semaphore)，有时被称为信号灯，是在多线程环境下使用的一种设施，是可以用来保证两个或多个关键代码段不被并发调用。在进入一个关键代码段之前，线程必须获取一个信号量；一旦该关键代码段完成了，那么该线程必须释放信号量。其它想进入该关键代码段的线程必须等待直到第一个线程释放信号量。为了完成这个过程，需要创建一个信号量 VI，然后将 Acquire Semaphore VI 以及 Release Semaphore VI 分别放置在每个关键代码段的首末端。确认这些信号量 VI 引用的是初始创建的信号量。
:::

11.
<img :src="$withBase('/process-thread/11.png')" alt="11">

操作系统的设计，因此可以归结为三点：

（1）以多进程形式，允许多个任务同时运行；

（2）以多线程形式，允许单个任务分成不同的部分运行；

（3）提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。

## js 相关

### 浏览器进程

浏览器作为一个计算机应用程序，如果打开浏览器默认进入一个空白页，相当于新起了一个浏览器的主进程和 GPU 进程，如果再打开一个标签页，则又创建了一个渲染进程。

::: tip 总结
浏览器是多进程的

浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）

浏览器每打开一个 Tab 页，就相当于创建了一个独立的浏览器进程。
:::

::: tip 优点
避免单个页面崩溃影响整个浏览器

避免第三方插件崩溃影响整个浏览器

多进程充分利用多核优势

方便使用沙盒模型隔离插件等进程，提高浏览器安全性

简单的说，浏览器多进程避免了一个页面或一个插件的崩溃导致整个浏览器的崩溃，大大改善了用户体验。
:::
::: tip 缺点
浏览器多进程提高用户体验的同时是要付出代价的，那就是对系统资源的消耗加大，特别是内存的消耗。
:::

### 浏览器有哪些进程

1. Browser 进程

   浏览器的主进程（负责协调、主控），只有一个，相当于浏览器的大脑

   ::: tip 作用
   负责浏览器界面显示，与用户交互，如前进，后退等；

   负责各个页面的管理，创建和销毁其他进程；

   将渲染线程得到的内存中的位图渲染到用户界面上；

   网络资源的管理，下载等。
   :::

2. 第三方插件进程

   每种类型的插件对应一个进程，仅当使用该插件时才创建——例 flash player

3. GPU 进程

   最多一个，负责 3D 绘制，只有当该页面使用了硬件加速才会使用它，来渲染页面。否则的话，不使用这个进程，而是用 Browser 进程来渲染页面。

4. 浏览器渲染进程（Renderer 进程）

   也称浏览器内核、Renderer 进程（内部是多线程的），默认每个 Tab 页面一个进程，互不影响。主要作用为页面渲染，脚本执行，事件处理，任务队列轮询等。
   浏览器有时会将多个渲染进程合并（譬如打开多个空白标签页后，会发现多个空白标签页被合并成了一个进程）。

### 前端重点：渲染进程（浏览器内核）

我们来捋一下进程和线程，浏览器是多进程的，每打开一个 tab 页相当于创建了一个渲染进程，每个渲染进程是又多线程的。页面的渲染，JS 的执行，事件的循环，都在渲染进程中进行。渲染进程中的主要常驻线程：

1. GUI 渲染线程

   负责渲染浏览器界面，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。

   当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行。

2. JS 引擎线程

   也称为 JS 内核，负责处理 Javascript 脚本程序。（例如 V8 引擎）

   JS 引擎线程负责解析 Javascript 脚本，运行代码。

   JS 引擎一直等待着任务队列中任务的到来，然后加以处理，浏览器无论什么时候都只有一个 JS 线程在运行 JS 程序，JS 是单线程的。

   PS：GUI 渲染线程与 JS 引擎线程是互斥的，当 JS 引擎执行时 GUI 线程会被挂起，GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行;如果 JS 执行的时间过长，会导致页面渲染被阻塞。

3. 事件触发线程

   接受浏览器里面的操作事件响应。如在监听到鼠标、键盘等事件的时候， 如果有事件处理函数，就将对应的任务压入任务队列（添加到待处理队列的队尾），等待 JS 引擎的处理。

   事件触发线程管理着一个任务队列。

4. 定时触发器线程

   setInternal 与 setTimeout 所在线程

   浏览器定时计数器并不是由 JavaScript 引擎计数的,（因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响计时的准确）

   因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待 JS 引擎空闲后执行）

   注意，W3C 在 HTML 标准中规定，规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms。

5. 异步 http 请求线程

   在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求

   将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。

### Browser 进程和渲染进程的通信过程

了解一下浏览器的主进程和渲染进程是怎样通信的：

1. Browser 进程收到用户请求（输入网址并回车），首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过 RendererHost 接口传递给 Render 进程。

2. Renderer 进程的 Renderer 接口收到消息，简单解释后，交给渲染线程，然后开始渲染。

   > - 渲染线程接收请求，加载网页并渲染网页，这其中可能需要 Browser 进程获取资源和需要 GPU 进程来帮助渲染；
   > - 可能会有 JS 线程操作 DOM（这样可能会造成回流并重绘）；
   > - 最后 Render 进程将结果传递给 Browser 进程；

3. Browser 进程接收到结果并将结果绘制出来。

（完）
